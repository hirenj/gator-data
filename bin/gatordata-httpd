#!/usr/bin/env node

MASCP = require('mascp-jstools');

var nconf = require('nconf');
var fs = require('fs');

nconf.env('__').argv();

nconf.file('config.json');

nconf.defaults({
    'port'   : 3000,
    'static' : false
});

var port = nconf.get('port');

var resource_map = {
    'tair'      : MASCP.TairReader,
    'uniprot'   : MASCP.UniprotReader,
    'atchloro'  : MASCP.AtChloroReader,
    'atpeptide' : MASCP.AtPeptideReader,
    'pep2pro'   : MASCP.Pep2ProReader,
    'gelmap'    : MASCP.GelMapReader,
    'interpro'  : MASCP.InterproReader,
    'p3db'      : MASCP.P3dbReader,
    'phosphat'  : MASCP.PhosphatReader,
    'ppdb'      : MASCP.PpdbReader,
    'promex'    : MASCP.PromexReader,
    'rippdb'    : MASCP.RippdbReader,
    'suba'      : MASCP.SubaReader,
    'user'      : MASCP.UserdataReader,
    'ArbitraryData' : MASCP.ArbitraryDataReader,
    'rnaedit'   : MASCP.RnaEditReader,
    'ubiquitin' : MASCP.UbiquitinReader,
    'processing': MASCP.ProcessingReader,
    'nssnps'    : MASCP.SnpReader,
};


MASCP.UserdataReader.datasets(function(service) {
    resource_map[service] = MASCP.UserdataReader;
});

var live_resources = nconf.get('liveupdate') || {};

(function() {
    var resource;
    for (resource in live_resources) {
        if ( ! resource_map[resource] ) {
            resource_map[resource] = MASCP.UserdataReader;
        }
    }
})();

nconf.save(function(err) {
    if (err) {
        console.log("Could not write config");
    }
});

process.on( 'SIGINT', function() {
    nconf.save(function(err) {
        if (err) {
            console.log("Error writing out configuration");
        }
        console.log("Clean exit, saving config file");
        process.exit();
    });
});

process.addListener("uncaughtException", function (err) {
    console.log("Uncaught exception: " + err);
    console.log(err.stack);
    // We should make sure state is clean here
});

var id_mapper;

var refresh_document = function(doc,map) {
    var reader = new MASCP.GoogledataReader();
    var inserter;
    inserter = reader.createReader(doc,map);
    return inserter;
};

var refresh_file = function(file,map,title) {
    var csv = require('csv');
    var data_array = [];
    var inserter = new MASCP.UserdataReader();
    inserter.datasetname = title;
    if (MASCP[title]) {
        inserter.toString = function() {
            return MASCP[title].toString();
        };
    }
    console.log("Inserting for "+inserter.toString());
    inserter.map = map;
    if (id_mapper) {
        inserter.map_id = id_mapper;
    } else {
        inserter.map_id = function(id) { return id; };
    }
    inserter.bind('progress',function(percent) {
        console.log("\u001b[1F\u001b[1K"+title+" insertion (\u001b[36;1m"+percent.toFixed(0)+"%\u001b[0m)");
    });
    MASCP.Service.ClearCache(inserter.toString(),null,function() {
        console.log("Cleared data out on "+inserter.toString());
        var read_stream = fs.createReadStream(file);
        if (file.match(/gz$/)) {
            var zlib = require('zlib');
            var zipped_stream = read_stream;
            read_stream = zipped_stream.pipe(zlib.createGunzip());
        }
        csv()
        .fromStream(read_stream, {
            delimiter : "\t",
            quote : "☃"
        }).on('data',function(dat) {
            data_array.push(dat);
        }).on('end',function() {
            console.log("Read file "+file+" for "+inserter.toString());
            inserter.setData(title,data_array);
        }).on('error',function(error) {
            console.log(error.message)
        });
    });

    return inserter;
};

var watching_block = nconf.get("watching:spreadsheet") || {};

var start_spreadsheet_watching = function() {
    console.log("Checking to see if any documents need to be updated");
    for (var doc_conf in watching_block) {
        var check_interval = watching_block[doc_conf].check_interval || 1000*60*60*24*7;
        if ((new Date()).getTime() - watching_block[doc_conf].last_check < check_interval ) {
            continue;
        }
        console.log("Checking document "+doc_conf);
        var inserter = refresh_document("spreadsheet:"+doc_conf,eval("("+watching_block[doc_conf].parser_function+")"));
        inserter.bind('ready',function() {
            var time = (new Date()).getTime();
            watching_block[doc_conf].last_check = time;
            nconf.set('watching:spreadsheet:'+doc_conf+':last_check', time);
            nconf.save(function(err) {
                if (err) {
                    console.log("Could not write config");
                } else {
                    console.log("Saved configuration");
                }
            });
        });
    }
    console.log("Checking next in a day");
    setTimeout(arguments.callee,1000*60*60*24);
};

var watching_datadoc_block = nconf.get("watching:datadoc") || {};

var start_datadoc_watching = function() {
    console.log("Checking to see if any documents need to be updated");
    for (var doc_conf in watching_datadoc_block) {
        var check_interval = watching_datadoc_block[doc_conf].check_interval || 1000*60*60*24*7;
        if ((new Date()).getTime() - watching_datadoc_block[doc_conf].last_check < check_interval ) {
            continue;
        }
        console.log("Checking document "+doc_conf);
        var inserter = refresh_document(doc_conf, datadoc_parser);
        inserter.bind('ready',function() {
            var time = (new Date()).getTime();
            watching_datadoc_block[doc_conf].last_check = time;
            nconf.set('watching:datadoc:'+doc_conf+':last_check', time);
            nconf.save(function(err) {
                if (err) {
                    console.log("Could not write config");
                } else {
                    console.log("Saved configuration");
                }
            });
        });
    }
    console.log("Checking next in a day");
    setTimeout(arguments.callee,1000*60*60*24);
};

var watch_file_block = nconf.get("watching:file") || {};

var start_document_watching = function() {
    for (var doc_conf in watch_file_block) {
        console.log("Watching "+doc_conf+" for changes");
        (function(doc_name) {
        fs.stat(doc_name,function(err,stats) {
            if (err) {
                return;
            }
            if (((stats.mtime.getTime() - watch_file_block[doc_name].last_check) > 0) || nconf.get("force")) {
                console.log(doc_name+" has changed, refreshing");
                var inserter = refresh_file(doc_name, eval("("+watch_file_block[doc_name].parser_function+")"),watch_file_block[doc_name].title);
                inserter.bind('ready',function() {
                    console.log("Reloaded data from "+doc_name);
                    resource_map[watch_file_block[doc_name].title] = MASCP.UserdataReader;
                    var time = (new Date()).getTime();
                    nconf.set('watching:file:'+doc_name+':last_check', time);
                    nconf.save(function(err) {
                        if (err) {
                            console.log("Could not write config");
                        } else {
                            console.log("Saved configuration");
                        }
                    });

                });
            }
        });
        fs.watch(doc_name,function(ev,filename) {
            console.log(doc_name+" has changed, refreshing");
            var inserter = refresh_file(doc_name, eval("("+watch_file_block[doc_name].parser_function+")"),watch_file_block[doc_name].title);
            inserter.bind('ready',function() {
                resource_map[watch_file_block[doc_name].title] = MASCP.UserdataReader;
                var time = (new Date()).getTime();
                nconf.set('watching:file:'+doc_name+':last_check', time);
                nconf.save(function(err) {
                    if (err) {
                        console.log("Could not write config");
                    } else {
                        console.log("Saved configuration");
                    }
                });
                console.log("Reloaded data from "+doc_name+" into "+inserter.toString());
            });
        });
        })(doc_conf);
    }
};

var watch_file = function(filename,map,title,callback) {
    if (nconf.get('watching:file:'+filename)) {
        var curr = nconf.get('watching:file:'+filename);
        if (curr.parser_function.toString() === (map || "").toString()) {
            console.log("Already watching file "+filename);
            if (callback) {
                callback();
            }
            return;
        }
    }
    var inserter = refresh_file(filename,map,title);
    inserter.bind('ready',function() {
        if (map) {
            var status = { "last_check" : (new Date()).getTime(), "parser_function" : map.toString(), "title" : title };
            nconf.set('watching:file:'+filename, status);
            nconf.save(function(err) {
                if (err) {
                    console.log("Could not write config");
                } else {
                    console.log("Data inserted for "+filename+" - will automatically update");
                }
                if (callback) {
                    callback(err);
                }
            });
        } else {
            console.log("Please try again with a defined parser function");
        }
    });
    inserter.bind('error',function() {
        if (callback) {
            callback.call("Some file error");
        }
    });
}

var datadoc_parser = function(datablock) {
    datablock.data['config'] = datablock.defaults;
    var all_accs = [];
    for (var acc in datablock.data) {
        datablock.data[acc] = { "data" : datablock.data[acc], "title" : datablock.title, "retrieved" : datablock.retrieved };
        if (acc !== "config") {
            all_accs.push(acc);
        }
    }
    datablock.data['accs'] = { "data" : all_accs };
    return datablock.data;
};


var watch_datadoc = function(doc,callback) {
    if (nconf.get('watching:datadoc:'+doc)) {
        var curr = nconf.get('watching:datadoc:'+doc);
        if (curr && curr.toString()) {
            console.log("Already watching document "+doc+" refreshing anyway");
        }
    }
    var inserter = refresh_document(doc,datadoc_parser);

    inserter.bind('ready',function() {
        console.log("Got data back for datadoc:"+doc);
        var status = { "last_check" : (new Date()).getTime() };
        watching_datadoc_block[doc] = status;
        nconf.set('watching:datadoc:'+doc, status);
        nconf.save(function(err) {
            if (err) {
                console.log("Could not write config");
            } else {
                if (callback) {
                    callback();
                }
                console.log("Data inserted - will automatically update for datadoc:"+doc);
            }
        });
    });
    inserter.bind('error',function(err) {
        console.log("Error retrieving data document for datadoc:"+doc);
        if (callback) {
            callback(err);
        }
    });
}

var watch_spreadsheet = function(doc,map,callback) {
    if (nconf.get('watching:spreadsheet:'+doc)) {
        var curr = nconf.get('watching:spreadsheet:'+doc);
        if (curr.parser_function.toString() === (map || "").toString()) {
            console.log("Already watching document "+doc+" refreshing anyway");
        }
    }
    if ( ! map ) {
        (new MASCP.GoogledataReader()).createReader("spreadsheet:"+doc,function(datablock) {
            if (Array.isArray(datablock.data)) {
                console.log(datablock.data.slice(0,5));
            } else {
                console.log(datablock.data);
            }
            console.log("We require a function that returns a signature of { accession : { data : {}, retrieved : 12345 } }"  );
        });
    } else {
        var vm = require('vm');
        try {
            vm.runInNewContext("("+map.toString()+")({ \"data\" : {} })", {"console" : console } , "<parser function>");
        } catch (e) {
            console.log("Error running map function. Make sure you do not use any local or global variables");
            console.log(e);
            return;
        }
    }

    var inserter = refresh_document("spreadsheet:"+doc,map);

    inserter.bind('ready',function() {
        console.log("Got data back for spreadsheet:"+doc);
        if (map) {
            var status = { "last_check" : (new Date()).getTime(), "parser_function" : map.toString() };
            watching_block[doc] = status;
            nconf.set('watching:spreadsheet:'+doc, status);
            nconf.save(function(err) {
                if (err) {
                    console.log("Could not write config");
                } else {
                    if (callback) {
                        callback();
                    }
                    console.log("Data inserted - will automatically update for spreadsheet:"+doc);
                }
            });
        } else {
            console.log("Please try again with a defined parser function");
            if (callback) {
                callback("Please try again with a defined parser function");
            }
        }
    });
    inserter.bind('error',function(err) {
        console.log("Error retrieving spreadsheet for spreadsheet:"+doc);
        if (callback) {
            callback(err);
        }
    });
};

var live_update = function(resource,clazz,merger) {
    var class_string;
    var dataset;
    if (typeof(clazz) == "string") {
        class_string = "MASCP.UserdataReader";
        dataset = clazz;
    } else {
        class_string = (new clazz()).toString();
    }
    var conf = { "merger_function" : merger.toString(), "class" : class_string };
    if (dataset) {
        conf['dataset'] = dataset;
    }
    nconf.set('liveupdate:'+resource,conf);
    nconf.save(function(err) {
        if (err) {
            console.log("Could not write config");
        } else {
            console.log("Set function for live update for "+resource);
        }
    });
};


var enable_id_translation = function(clazz) {
    (function(serv) {
        var defaultDataReceived = serv.prototype._dataReceived;

        serv.prototype._dataReceived = function(data,status)
        {
            if (data === null) {
                return defaultDataReceived.call(this,null,status);
            }
            if (typeof data == "object") {
                return defaultDataReceived.call(this,data,status);
            }

            if (typeof data == "string") {
                if (data.toLowerCase().match(/^at/)) {
                    this.agi = data.toLowerCase().replace(/(\n|\r)+$/,'')+'.1';
                    this.retrieve(this.agi);
                    return;
                } else {
                    return defaultDataReceived.call(this,null,status);
                }
            }
        };
    })(clazz);
    var old_request = clazz.prototype.requestData;

    clazz.prototype.requestData = function()
    {
        var self = this;
        var agi = this.agi || '';
        if (! agi.toLowerCase().match(/^at/)) {
            return {
                type: "GET",
                dataType: "txt",
                url: "http://uniprot.org/mapping/",
                data : {
                    "from" : "ACC+ID",
                    "to" : "TAIR_ID",
                    "format" : "list",
                    "query" : agi
                }
            }
        }
        return old_request.call(this);
    };

};

if (port == 3702) {
    enable_id_translation(MASCP.SnpReader);
}


repl = require('repl');

MASCP.events.once('all_ready',function() {
    MASCP.Service.BeginCaching();
    var express = require('express'),
        app = express.createServer();


    var htmldir = nconf.get("webdir") || __dirname + '/../www';

    app.configure(function() {
        app.use(express.bodyParser());
        app.use(function(req, res, next) {
            var matchUrl = '/js';
            if(req.url.replace(/\/+/,'/').substring(0, matchUrl.length) === matchUrl) {
              res.setHeader("Access-Control-Allow-Origin", "*");
            }
            return next();
        });
        app.use(express.static(htmldir));
        app.use(express.static(__dirname + '/../node_modules/mascp-jstools/dist'));
        app.use(app.router);
    });
    
    if (nconf.get('static')) {
        app.listen(port,'127.0.0.1');
        console.log('Server running at http://127.0.0.1:'+port+'/');
        return;
    }

    express.static.mime.define({'image/svg+xml': ['svg']});

    app.get("/", function(req, res) {
      res.redirect("/index.html");
    });
    (function() {
        var middle = express.static(htmldir);
        app.get("/comparison/*", function(req, res, next) {
            req.url = '/index.html';
            middle(req,res,next);
        });
    })();


    (function() {
        var middle = express.static(htmldir);
        app.get("/cazy/*", function(req, res, next) {
            req.url = '/index.html';
            middle(req,res,next);
        });
    })();

    (function() {
        var middle = express.static(__dirname + '/../www');
        app.get("/uniprot/*", function(req, res, next) {
            req.url = '/index.html';
            middle(req,res,next);
        });
    })();

    var get_file = function(file,callback) {
        fs.readFile(file, 'utf8', function (err, data) {
          if (err) {
            console.log('Error: ' + err);
            return;
          }
          callback.call(null,JSON.parse(data));
        });
    };

    (function() {
        var middle = express.static(__dirname + '/../www');
        app.get("/doi/*/", function(req, res, next) {
            req.url = '/index.html';
            middle(req,res,next);
        });
        var doi_map = {};
        var seen_redirect = false;
        fs.readdir(__dirname + '/../pubs',function(err,files) {
            files.forEach(function(file) {
                if (! file.match(/json/)) {
                    return;
                };
                get_file(__dirname + '/../pubs/'+file,function(dat) {
                    if (dat.doi) {
                        doi_map[dat.doi] = file;
                        if (dat.shortcut) {
                            var redirects = fs.createWriteStream(__dirname + '/../etc/nginx/redirects', {'flags': seen_redirect ? 'a' : 'w'});
                            redirects.write("rewrite  ^/doi/"+dat.shortcut+"/$  /doi/"+dat.doi+"/ permanent;");
                            seen_redirect = true;
                        }
                    } else {
                        if (dat.shortcut) {
                            doi_map[dat.shortcut] = file;
                        }
                    }
                });
            });
        });

        var middle_doi = express.static(__dirname + '/../pubs');
        app.get("/doi/*", function(req, res, next) {
            req.url = (doi_map[req.params[0] || ""] || "unknown.json");
            middle_doi(req,res,next);
        });

    })();

    var data_headers = function(req,res,next) {
        res.header('Content-type', 'application/json');
        res.header('Access-Control-Allow-Headers','x-requested-with');
        res.header('Access-Control-Max-Age','1728000');
        res.header('Access-Control-Allow-Origin','*');
        res.header('Access-Control-Allow-Methods','*');        
        next();
    }

    app.post('/data/*',data_headers);
    app.get('/data/*',data_headers);
    
    app.post('/tools/*', data_headers);

    app.get('/data/history/:resource/:date/:agi',function(req,res,next) {
        var service = service_object(req);
        var date = new Date(Date.parse(req.param('date')+' UTC'));
        MASCP.Service.SetMaximumAge(date);
        if ( ! service)  {
            res.send({"error" : "No service"}, 404);
            return;
        }
        service.retrieve(req.param('agi'),function(err) {
            if (! this.result || this.result === null || ! this.result._raw_data || ! this.result._raw_data.retrieved) {
                res.send({"error" : "No data"},404);
                return;
            }
            if (this.result._raw_data.retrieved.getTime() != date.getTime()) {
                var actual = this.result._raw_data.retrieved;
                console.log("redirecting to "+actual);
                var daystring = actual.getUTCDate();
                if (daystring < 10) {
                    daystring = '0'+daystring.toString();
                }
                var monthstring = actual.getUTCMonth()+1;
                if (monthstring < 10) {
                    monthstring = '0'+monthstring.toString();
                }
                res.redirect("/data/history/"+req.param('resource')+'/'+actual.getUTCFullYear()+'-'+monthstring+'-'+daystring+'/'+req.param('agi'));
            } else {
                res.send(this.result ? this.result._raw_data : {},200);
            }
        });
    });

    app.get('/data/latest/cazy/:family',function(req,res,next) {
        var tax = '9606';
        if (app.address().port != 3000) {
            tax = app.address().port;
        }

        var opts = {'host' : 'www.uniprot.org',
                    'port' : 80,
                    'path' : '/uniprot/?query=('+req.param('family').toUpperCase()+')+AND+reviewed%3ayes+AND+taxonomy%3a'+tax+'&format=tab&columns=id,genes'
                    };
        var client = require('http').get(opts,
        function(response) {
            response.on('data', function (chunk) {
                var ids = chunk.toString().replace(/\n/g,',');
                ids = ids.replace(/,$/,'');
                res.send(ids.split(',').map(function(row) { var cols = row.split(/\t/); return { "id" : cols[0], "name" : cols[1].replace(/\s+.*/,'') } }).slice(1),200);
            });
        }).on('error', function(e) {
            res.send({"error" : "Could not contact Uniprot"},200);
        });
    });
    
    app.get('/data/latest/gator',function(req,res,next) {
        var agi = req.query.agi || req.query.acc;
        get_latest(agi,service_object(req),res);
    });
    app.post('/data/latest/gator',function(req,res,next) {
        var agi = req.body.agi || req.body.acc;
        get_latest(agi,service_object(req),res);
    });

    app.get('/data/latest/gator/:acc',function(req,res,next) {
        var acc = req.param('acc') || req.query.acc || req.query.agi;
        get_latest(acc,service_object(req),res);        
    });

    var retrieve_latest = function(agi,service,res,old_data) {
        var live_resource = live_resources[service.resource_name];
        if ( ! live_resource ) {
            return false;
        }
        var merger_func = eval("("+live_resource.merger_function+")");
        var clazz = eval("("+live_resource.class+")");
        var service = new clazz();
        if (clazz === MASCP.UserdataReader) {
            service.datasetname = live_resource.dataset;
            MASCP.Service.BeginCaching(service);
        }
        if ( ! clazz.running ) {
            clazz.running = {};
        }
        service.bind('running',function() {
            clazz.running[this.agi.toLowerCase()] = true;

            if (res.header) {
                res.header('Refresh','10;');
            }
            res.send({"status" : "RUNNING"},202);
            res = { "send" : function() {} };
        });
        if (clazz.running[agi.toLowerCase()] === true) {
            if (res.header) {
                res.header('Refresh','10;');
            }
            res.send({"status" : "RUNNING"},202);
            return true;
        }

        service.retrieve(agi,function(err) {
            delete clazz.running[this.agi.toLowerCase()];
            if (err && ! old_data) {
                res.send(err.error ? { "error" : err.error } : { "error" : err },200);
                return;
            }
            if (err) {
                res.send(old_data,200);
                return;
            }
            if ( ! old_data ) {
                old_data = {};
            }
            if ( ! this.result ) {
                res.send({"error" : "No data"},200);
                return;
            }
            old_data._raw_data = merger_func(old_data._raw_data,this.result._raw_data);
            res.send(old_data._raw_data,200);
        });
        return true;
    };

    var service_object = function(req) {
        req.query = req.query || {};
        req.body = req.body || {};
        var resource = req.param('resource') || req.query.service || req.body.service;
        var clazz = resource_map[resource];
        if ( ! clazz ) {
            return;
        }
        var obj = new clazz(null,null);
        if (clazz == MASCP.ArbitraryDataReader) {
            obj = obj._extend(req.query.dataset || req.body.dataset);
        }
        if (clazz == MASCP.UserdataReader) {
            obj.datasetname = resource;
        }
        obj.resource_name = resource;
        return obj;
    };

    var get_latest = function(agi,service,res) {
        if ( ! service)  {
            res.send({"error" : "No service"}, 404);
            return;
        }
        MASCP.Service.SetMaximumAge(0);
        service.retrieve(agi,function(err) {
            if (err || this.result && this.result._raw_data && this.result._raw_data.nodeName) {
                res.send(err.error ? { "error" : err.error } : { "error" : err },200);
            } else {
                if ( ! retrieve_latest(agi,service,res,this.result) ) {
                    res.send(this.result ? this.result._raw_data : {"error" : "No data"},200);
                }
            }
        });        
    }
    
    app.get('/data/latest/:resource',function(req,res,next) {
        get_latest(req.query.agi || req.query.acc, service_object(req),res);
    });
    
    app.get('/data/latest/:resource/:agi',function(req,res,next) {
        get_latest(req.param('agi'), service_object(req), res);
    });

    var clustal_running = {};

    app.post('/tools/clustalw/', function(req,res,next) {
        var sequences = (req.body.sequences || "").split(",");
        var clustal = new MASCP.ClustalRunner();
        clustal.sequences = sequences;
        clustal.agi = MASCP.ClustalRunner.hash(clustal.sequences.join(','))+'';
        if (clustal_running[clustal.agi] === true) {
            res.send({"status" : "RUNNING"},202);
            return;
        }
        clustal.bind('running',function() {
            clustal_running[clustal.agi] = true;
            res.send({"status" : "RUNNING"},202);
            res = { "send" : function() {} };
        });
        clustal.retrieve(clustal.agi,function(err) {
            if ( err && ! err.error ) {
                err.error  = err.message;
            }
            delete clustal_running[this.agi];
            if (err || this.result && this.result._raw_data && this.result._raw_data.nodeName) {
                res.send(err.error ? { "error" : err.error } : { "error" : err },200);
            } else {
                res.send(this.result ? this.result._raw_data : {"error" : "No data"},200);
            }
        });

        return;

    });

    if ( ! nconf.get("bootstrap") ) {
        app.listen(port);//,'127.0.0.1');
        console.log('Server running at http://127.0.0.1:'+app.address().port+'/');
    }

    if (! require('tty').isatty(process.stdin)) {
        var vm = require('vm');
        var running = 0;
        var auto_exit = function(actual_func) {
            return function() {
                running++;
                actual_func.apply(null,Array.prototype.slice.call(arguments).concat(
                    function(err) {
                    running--;
                    setTimeout(function() {
                        if (running == 0) {
                            process.exit();
                        }
                    },100);
                    })
                );
            };
        };
        try {
            vm.runInNewContext(require('fs').readFileSync('/dev/stdin').toString(), { resource_map: resource_map, require: require, console: console, MASCP: MASCP, module: module, watch_spreadsheet: auto_exit(watch_spreadsheet), watch_datadoc: auto_exit(watch_datadoc), watch_file : auto_exit(watch_file), live_update : live_update }, "<stdin>");
        } catch (e) {
            console.log("Error running script");
            console.log(e);
        }
    } else {

        if (nconf.get("watch")) {
            start_document_watching();
            start_spreadsheet_watching();
            start_datadoc_watching();
        }
        if ( ! nconf.get("headless") ) {
            repl.start("Gator data server >");
            repl.repl.context.resource_map = resource_map;
            repl.repl.context.watch_spreadsheet = watch_spreadsheet;
            repl.repl.context.watch_file = watch_file;
        }
    }

});

MASCP.events.once('ready',function() {
    if (nconf.get("mappings")) {
        var file = nconf.get("mappings");
        var read_stream = fs.createReadStream(file);
        (function() {
            var csv = require('csv');
            var mappings = {};
            if (file.match(/gz$/)) {
                var zlib = require('zlib');
                var zipped_stream = read_stream;
                read_stream = zipped_stream.pipe(zlib.createGunzip());
            }
            console.log("Loading mappings");
            csv()
            .fromStream(read_stream, {
                delimiter : "\t",
                quote : "☃"
            }).on('data',function(dat) {
                var ids = dat[3].split(/;\s+/);
                ids.forEach(function(id) {
                    mappings[id.toLowerCase()] = dat[0].toLowerCase();
                });
            }).on('end',function() {
                id_mapper = function(id) {
                    if (mappings[id.toLowerCase()]) {
                        return mappings[id.toLowerCase()];
                    } else {
                        return id;
                    }
                };
                console.log("Loaded up mappings");
                MASCP.events.emit('all_ready');
            }).on('error',function(error) {
                console.log(error.message)
            });
        })();
    } else {
        MASCP.events.emit('all_ready');
    }
});

MASCP.events.emit('ready');